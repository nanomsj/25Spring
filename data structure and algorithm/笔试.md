### 数据结构与算法B

###### compiled by nanomsj

###### source: yhf's written-exam paper

------

##### “全是选择”分类刷题

1. **逻辑结构**是抽象出的结构，关注的是数据元素之间的关联方式（如集合、线性、树形、图结构等 ），和数据元素本身的形式、内容、相对位置、个数无关

2. **数据元素**是数据的**基本单位**，**数据项**是**最小单位**（例子：学生（数据元素）：姓名、学号、年龄（数据项））

3. 有序表强调的是数据元素按一定顺序（如升序、降序 ）排列的逻辑结构，不涉及具体存储方式，与存储结构无关。线性表也是。

4. 顺序表定义：用一段<u>物理地址连续</u>的存储单元

5. 链栈：用链式存储结构实现的栈

6. 顺序表插入/删除操作要移动一半的元素→效率较低

7. 单链表存数据+指针

8. 建立一个有序单链表，需<u>依次</u>插入 n 个元素，每次插入要遍历找合适位置（最多遍历到链表末尾 ），时间复杂度为 $O(n^2)$ 。

9. 队列：front队头指针……rear队尾指针。队空条件是rear == front；n为最大容量时，(rear + 1) % n == front 是队满的条件。

10. 树转二叉树：左孩子右兄弟：**形态唯一**

    ```
    B 是 A 的第一个子节点 → 作为 A 的左孩子；
    C 是 B 的 “兄弟” → 作为 B 的右孩子；
    D 是 C 的 “兄弟” → 作为 C 的右孩子；
    ```

11. 二叉树访问顺序（看根节点）

    - 前序遍历：根→左→右
    - 中序遍历：左 → 根 → 右
    - 后序遍历：**左→右**→根：可以先处理子树再处理父节点（如交换左右子树），利于操作父子依赖关系强的问题

12. n个节点结构不同的二叉树：$C_n=\frac{1}{n+1}C_{2n}^n$

13. 完全二叉树中n_1=0或1（奇数则0，偶数则1），$n_0=n_2+1$

    例题：一棵完全二叉树上有 1001 个结点，其中叶子结点的个数是（501）

14. | 树的存储方法   | 说明                          |
    | -------------- | ----------------------------- |
    | 双亲表示法     | 数组记录父节点                |
    | 孩子链表表示法 | 每个节点用链表/数组存所有孩子 |
    | 孩子兄弟表示法 | 左孩子右兄弟模拟多叉树        |

15. 对于一个**连通无向图** G，其生成树是包含 G 的**所有顶点**，且**边数最少**的连通子图。n个顶点→n-1边。连通图邻接矩阵非零元素（每条边占位2）最少数目2*（n-1）

16. | 对比维度     | 连通                         | 强连通                                                 |
    | ------------ | ---------------------------- | ------------------------------------------------------ |
    | 适用图类型   | 无向图                       | 有向图                                                 |
    | 顶点连通条件 | 两顶点间**存在至少一条路径** | 两顶点u、v间**同时存在 \(u→v\) 和 \(v→u\) 的有向路径** |

17. 几种图的算法

    | 算法     | 核心功能                                            | 适用场景                   | 关键思想                         |
    | -------- | --------------------------------------------------- | -------------------------- | -------------------------------- |
    | Prim     | 构造<u>无向图最小生成树</u>：连通+边的权值最小+无环 | 稠密图（邻接矩阵高效）     | 从顶点出发，逐步选最小边扩生成树 |
    | Kruskal  | 构造无向图最小生成树                                | 稀疏图（边少更优）         | 按边权排序，用并查集避环选边     |
    | Floyd    | 求多源（所有顶点对）最短路径                        | 任意图（边权可负，无负环） | 动态规划，通过中间点松弛更新距离 |
    | Dijkstra | 求单源（一个起点）最短路径                          | 边权非负的图               | 贪心，选当前最短距离顶点松弛     |

18. BFS：队列，层次遍；DFS：栈，历先序遍历

19. 拓扑排序常用于环路判定

20. 邻接表：顶点+数组（直接相邻的顶点）

21. ~~m阶B-树(不考)~~

22. 哈希查找处理冲突：

    - 链地址法
    - 开放定址法
      - 线性探测 +1
      - 二次探测（+1，+4，+9）

23. 选择排序：每次把最小/最大者找出来

24. 排序稳定性：

    | 排序算法 | 稳定性 | 核心原因                                                     |
    | -------- | ------ | ------------------------------------------------------------ |
    | 冒泡排序 | 稳定   | 相邻元素比较，相等时不交换，相对位置保留                     |
    | 插入排序 | 稳定   | 插入时遇到相等值，会放在已排序序列相等值的后面，不改变相对位置 |
    | 归并排序 | 稳定   | 合并子序列时，遇到相等值优先取左子序列的元素，保证相对位置   |
    | 基数排序 | 稳定   | 按位排序时，低位相同的元素，高位排序不影响其相对位置（基于桶 / 计数思想 ） |
    | 选择排序 | 不稳定 | 选极值交换时，可能把前面的相等值交换到后面，破坏相对位置（如 `5,8,5,2` ） |
    | 快速排序 | 不稳定 | 基准与元素交换时，可能打乱相等值的原有相对位置               |
    | 希尔排序 | 不稳定 | 多轮插入排序中，相同值可能在不同步长下移动，破坏相对位置     |
    | 堆排序   | 不稳定 | 调整堆时，相同值的交换可能破坏原有相对位置                   |

25. 堆、堆排序 [参考视频](https://www.bilibili.com/video/BV1AF411G7cA/?spm_id_from=333.1391.0.0)

-------------

##### 2021

1. 连通分量：极大连通子图；生成树：极小连通子图。强连通分量同理

2. 二叉排序树（BST）动态查找时，平均时间复杂度 $O(\log n)$ ，增删查都可高效完成。所以适合动态查找表高效查找

3. 树的度=节点度的最大值

4. 树：节点总数 = 边数 + 1，且 边数 = [$\sum$（度数+1）-1]÷ 2

5. 堆
   - 建堆本身是O(N)
   - 堆排序（含建堆 + 排序）才是O(N logN)
   
6. rear是**待插入**元素的位置

7. 最小生成树

   | 特性         | Prim 算法                      | Kruskal 算法                      |
   | ------------ | ------------------------------ | --------------------------------- |
   | 适用场景     | 稠密图（边多，\(n^2\) 高效）   | 稀疏图（边少，\(m \log m\) 高效） |
   | 核心逻辑     | 选 “连接生成树与外部” 的最小边 | 选全局最小边（用并查集避环）      |
   | 数据结构依赖 | 数组 / 堆                      | 并查集 + 排序                     |

##### 2022

1. 任意有向无环图（DAG）都可以用 DFS 或 BFS 求解拓扑排序
2. 哈夫曼树&WPL(带权外部路径长度)
3. 主存储器（RAM）有限时推荐使用**归并排序**，但其本身需要O(n)的空间。
4. 邻接入边表
5. 分治与动规
   - **分治算法**：分解出的子问题**相互独立、不重叠**（比如归并排序，拆分左右子数组排序，两边无交集 ）。
   - **动态规划**：子问题**存在大量重叠**（比如斐波那契数列，计算 `fib(5)` 会重复算 `fib(3)` 、`fib(2)` 等 ），需用 “记忆化” 避免重复计算。<u>要求一个问题必须拥有重叠子问题和最优子结构</u>
6. 查找要注意失败带来的次数增加
7. n个节点有向强连通图至少n条边

##### 2023

1. 分清“时间”“空间”

2. 内存开销：看是不是原地排序，是则O(1)；反之，如“归并排序”为O(n)

3. 分清“大于”“不小于”

4. 使用线性探测法处理散列表碰撞问题，若表中仍有空槽（空单元），插入操作一定成功。

5. 二叉树计算：
   $$
   n_0+n_1+n_2=总结点数\\
   n_1+2n_2=总边数=总结点数-1
   $$
   

##### 2024

1. 图的存储：n个顶点m条边
   1. 邻接表：空间复杂度O(m+n)，适合存储稀疏图，删除一个顶点的最坏情况的时间复杂度为O(m+n)
   2. 邻接矩阵：空间复杂度O(n**2)，适合存储稠密图，删除一个顶时间复杂度O(n\*\*2)
2. 连通分量是极大连通子图
3. 二路归并就是两两一组不断合并。
